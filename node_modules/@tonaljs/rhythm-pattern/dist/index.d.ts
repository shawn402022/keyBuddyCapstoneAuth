type RhythmPatternValue = 0 | 1;
type RhythmPattern = Array<RhythmPatternValue>;
/**
 * Create a rhythm pattern from a number or concatenation of numbers in binary form
 * @param numbers one or more number
 * @returns an array of 0s and 1s representing the rhythm pattern
 * @example
 * binary(13) // => [1, 1, 0, 1]
 * binary(12, 13) // => [1, 1, 0, 0, 1, 1, 0, 1]
 */
declare function binary(...numbers: number[]): RhythmPattern;
/**
 * Create a rhythmic pattern using an hexadecimal numbers
 * @param hexNumber string with the hexadecimal number
 * @returns an array of 0s and 1s representing the rhythm pattern
 * @example
 * R.hex("8f"); // => [1, 0, 0, 0, 1, 1, 1, 1]
 */
declare function hex(hexNumber: string): RhythmPattern;
/**
 * Create a rhythm pattern from the onsets
 * @param numbers the onsets sizes
 * @returns an array of 0s and 1s representing the rhythm pattern
 * @example
 * onsets(1, 2, 2, 1) // => [1, 0, 1, 0, 0, 1, 0, 0, 1, 0]
 */
declare function onsets(...numbers: number[]): RhythmPattern;
/**
 * Create a random rhythm pattern with a specified length
 * @param length length of the pattern
 * @param probability Threshold where random number is considered a beat (defaults to 0.5)
 * @param rnd A random function (Math.random by default)
 * @returns an array of 0s and 1s representing the rhythm pattern
 * @example
 * random(4) // => [1, 0, 0, 1]
 */
declare function random(length: number, probability?: number, rnd?: () => number): RhythmPattern;
/**
 * Create a rhythm pattern based on the given probability thresholds
 * @param probabilities An array with the probability of each step to be a beat
 * @param rnd A random function (Math.random by default)
 * @returns an array of 0s and 1s representing the rhythm pattern
 * @example
 * probability([0.6, 0, 0.2, 0.5]) // => [0, 0, 0, 1]
 */
declare function probability(probabilities: number[], rnd?: () => number): RhythmPattern;
/**
 * Rotate a pattern right
 * @param pattern the pattern to rotate
 * @param rotations the number of steps to rotate
 * @returns the rotated pattern (an array of 0s and 1s)
 * @example
 * rotate([1, 0, 0, 1], 2); // => [0, 1, 1, 0]
 *
 */
declare function rotate(pattern: RhythmPattern, rotations: number): RhythmPattern;
/**
 * Generates an euclidean rhythm pattern
 * @param steps The length of the pattern
 * @param beats The number of beats
 * @returns an array with 0s and 1s representing the rhythmic pattern
 * @example
 * euclid(8, 3); // => [1, 0, 0, 1, 0, 0, 1, 0]
 */
declare function euclid(steps: number, beats: number): RhythmPattern;

export { type RhythmPattern, binary, euclid, hex, onsets, probability, random, rotate };
