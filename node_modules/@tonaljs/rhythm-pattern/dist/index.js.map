{"version":3,"sources":["../index.ts"],"sourcesContent":["type RhythmPatternValue = 0 | 1;\n\nexport type RhythmPattern = Array<RhythmPatternValue>;\n\n/**\n * Create a rhythm pattern from a number or concatenation of numbers in binary form\n * @param numbers one or more number\n * @returns an array of 0s and 1s representing the rhythm pattern\n * @example\n * binary(13) // => [1, 1, 0, 1]\n * binary(12, 13) // => [1, 1, 0, 0, 1, 1, 0, 1]\n */\nexport function binary(...numbers: number[]): RhythmPattern {\n  return numbers.reduce((pattern, number) => {\n    number\n      .toString(2)\n      .split(\"\")\n      .forEach((digit: string) => {\n        pattern.push(parseInt(digit) as RhythmPatternValue);\n      });\n    return pattern;\n  }, [] as RhythmPattern);\n}\n\n/**\n * Create a rhythmic pattern using an hexadecimal numbers\n * @param hexNumber string with the hexadecimal number\n * @returns an array of 0s and 1s representing the rhythm pattern\n * @example\n * R.hex(\"8f\"); // => [1, 0, 0, 0, 1, 1, 1, 1]\n */\nexport function hex(hexNumber: string): RhythmPattern {\n  const pattern: RhythmPattern = [];\n  for (let i = 0; i < hexNumber.length; i++) {\n    const digit = parseInt(\"0x\" + hexNumber[i]);\n    const binary = isNaN(digit) ? \"0000\" : digit.toString(2).padStart(4, \"0\");\n    binary.split(\"\").forEach((digit: string) => {\n      pattern.push(digit === \"1\" ? 1 : 0);\n    });\n  }\n  return pattern;\n}\n\n/**\n * Create a rhythm pattern from the onsets\n * @param numbers the onsets sizes\n * @returns an array of 0s and 1s representing the rhythm pattern\n * @example\n * onsets(1, 2, 2, 1) // => [1, 0, 1, 0, 0, 1, 0, 0, 1, 0]\n */\nexport function onsets(...numbers: number[]): RhythmPattern {\n  return numbers.reduce((pattern, number) => {\n    pattern.push(1);\n    for (let i = 0; i < number; i++) {\n      pattern.push(0);\n    }\n    return pattern;\n  }, [] as RhythmPattern);\n}\n\n/**\n * Create a random rhythm pattern with a specified length\n * @param length length of the pattern\n * @param probability Threshold where random number is considered a beat (defaults to 0.5)\n * @param rnd A random function (Math.random by default)\n * @returns an array of 0s and 1s representing the rhythm pattern\n * @example\n * random(4) // => [1, 0, 0, 1]\n */\nexport function random(\n  length: number,\n  probability = 0.5,\n  rnd: () => number = Math.random,\n): RhythmPattern {\n  const pattern: RhythmPattern = [];\n  for (let i = 0; i < length; i++) {\n    pattern.push(rnd() >= probability ? 1 : 0);\n  }\n  return pattern;\n}\n\n/**\n * Create a rhythm pattern based on the given probability thresholds\n * @param probabilities An array with the probability of each step to be a beat\n * @param rnd A random function (Math.random by default)\n * @returns an array of 0s and 1s representing the rhythm pattern\n * @example\n * probability([0.6, 0, 0.2, 0.5]) // => [0, 0, 0, 1]\n */\nexport function probability(\n  probabilities: number[],\n  rnd: () => number = Math.random,\n): RhythmPattern {\n  return probabilities.map((probability) => (rnd() <= probability ? 1 : 0));\n}\n\n/**\n * Rotate a pattern right\n * @param pattern the pattern to rotate\n * @param rotations the number of steps to rotate\n * @returns the rotated pattern (an array of 0s and 1s)\n * @example\n * rotate([1, 0, 0, 1], 2); // => [0, 1, 1, 0]\n *\n */\nexport function rotate(\n  pattern: RhythmPattern,\n  rotations: number,\n): RhythmPattern {\n  const len = pattern.length;\n  const rotated: RhythmPattern = [];\n  for (let i = 0; i < len; i++) {\n    const pos = (((i - rotations) % len) + len) % len;\n    rotated[i] = pattern[pos];\n  }\n  return rotated;\n}\n\n/**\n * Generates an euclidean rhythm pattern\n * @param steps The length of the pattern\n * @param beats The number of beats\n * @returns an array with 0s and 1s representing the rhythmic pattern\n * @example\n * euclid(8, 3); // => [1, 0, 0, 1, 0, 0, 1, 0]\n */\nexport function euclid(steps: number, beats: number): RhythmPattern {\n  const pattern: RhythmPattern = [];\n  let d = -1;\n\n  for (let i = 0; i < steps; i++) {\n    const v = Math.floor(i * (beats / steps));\n    pattern[i] = v !== d ? 1 : 0;\n    d = v;\n  }\n  return pattern;\n}\n"],"mappings":";;;;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAYO,SAAS,UAAU,SAAkC;AAC1D,SAAO,QAAQ,OAAO,CAAC,SAAS,WAAW;AACzC,WACG,SAAS,CAAC,EACV,MAAM,EAAE,EACR,QAAQ,CAAC,UAAkB;AAC1B,cAAQ,KAAK,SAAS,KAAK,CAAuB;AAAA,IACpD,CAAC;AACH,WAAO;AAAA,EACT,GAAG,CAAC,CAAkB;AACxB;AASO,SAAS,IAAI,WAAkC;AACpD,QAAM,UAAyB,CAAC;AAChC,WAAS,IAAI,GAAG,IAAI,UAAU,QAAQ,KAAK;AACzC,UAAM,QAAQ,SAAS,OAAO,UAAU,CAAC,CAAC;AAC1C,UAAMA,UAAS,MAAM,KAAK,IAAI,SAAS,MAAM,SAAS,CAAC,EAAE,SAAS,GAAG,GAAG;AACxE,IAAAA,QAAO,MAAM,EAAE,EAAE,QAAQ,CAACC,WAAkB;AAC1C,cAAQ,KAAKA,WAAU,MAAM,IAAI,CAAC;AAAA,IACpC,CAAC;AAAA,EACH;AACA,SAAO;AACT;AASO,SAAS,UAAU,SAAkC;AAC1D,SAAO,QAAQ,OAAO,CAAC,SAAS,WAAW;AACzC,YAAQ,KAAK,CAAC;AACd,aAAS,IAAI,GAAG,IAAI,QAAQ,KAAK;AAC/B,cAAQ,KAAK,CAAC;AAAA,IAChB;AACA,WAAO;AAAA,EACT,GAAG,CAAC,CAAkB;AACxB;AAWO,SAAS,OACd,QACAC,eAAc,KACd,MAAoB,KAAK,QACV;AACf,QAAM,UAAyB,CAAC;AAChC,WAAS,IAAI,GAAG,IAAI,QAAQ,KAAK;AAC/B,YAAQ,KAAK,IAAI,KAAKA,eAAc,IAAI,CAAC;AAAA,EAC3C;AACA,SAAO;AACT;AAUO,SAAS,YACd,eACA,MAAoB,KAAK,QACV;AACf,SAAO,cAAc,IAAI,CAACA,iBAAiB,IAAI,KAAKA,eAAc,IAAI,CAAE;AAC1E;AAWO,SAAS,OACd,SACA,WACe;AACf,QAAM,MAAM,QAAQ;AACpB,QAAM,UAAyB,CAAC;AAChC,WAAS,IAAI,GAAG,IAAI,KAAK,KAAK;AAC5B,UAAM,QAAS,IAAI,aAAa,MAAO,OAAO;AAC9C,YAAQ,CAAC,IAAI,QAAQ,GAAG;AAAA,EAC1B;AACA,SAAO;AACT;AAUO,SAAS,OAAO,OAAe,OAA8B;AAClE,QAAM,UAAyB,CAAC;AAChC,MAAI,IAAI;AAER,WAAS,IAAI,GAAG,IAAI,OAAO,KAAK;AAC9B,UAAM,IAAI,KAAK,MAAM,KAAK,QAAQ,MAAM;AACxC,YAAQ,CAAC,IAAI,MAAM,IAAI,IAAI;AAC3B,QAAI;AAAA,EACN;AACA,SAAO;AACT;","names":["binary","digit","probability"]}